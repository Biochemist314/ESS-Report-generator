#Documentation /Script to create an automated text generator.

#The python script will be run inside the project folder and grab some insoformation and fill in the blanks.

#1)A script to extract some information
#2)Python script takes input ---> run.tex file that can then be compiled

project = input("project: ")
run = input("run: ")

#1)
#Now we need to extact certain general stats on read numbers. This was used in extract_metric.sh

#NUMBER_OF_READS=$(grep ${ONE_SAMPLE} ./09_QC_reports/${PROJECT_FOLDER_NAME}_sequencing_qc_data/multiqc_general_stats.txt | awk '{print $6}' | head -n1)
#NUMBER_OF_READS_AFTER_TRIMMING=$(grep ${ONE_SAMPLE} ./09_QC_reports/${PROJECT_FOLDER_NAME}_sequencing_qc_data/multiqc_general_stats.txt | awk '{print $6}'| head -n2 | tail -n1)

import os

#This is the definition unsure if it works as I keep getting syntax error.
#When typing it manually interactively it does seem to work. I am usure if it doesn't like
def data_extraction_multiqc(project,run):
    reads_stats=["sample name","total reads"]
    multiq_general_path_initial=os.path.join(os.path.expanduser('.'), '09_QC_reports', str(project)+'_'+str(run)+'_initial_sequencing_qc_data', 'multiqc_general_stats.txt')
    #multiq_general_path_sequencing=os.path.join(os.path.expanduser('.'), '09_QC_reports', str(project)+'_'+str(run)+'_sequencing_qc_data', 'multiqc_general_stats.txt')
#multiq_general_path_initial = ".\\09_QC_reports\\10569_M0363_initial_sequencing_qc_data\\multiqc_general_stats.txt"
    infile = open(multiq_general_path_initial, 'r')
    #infile2 = open(multiq_general_path_sequencing, 'r')
    lines = infile.readlines()
    #lines2 = infile2.readlines()
    for line in lines:
        sline = line.split('\t')
        #sline2 = line2.split('\t')  # separates line into a list of items.  ',' tells it to split the lines at the commas
        total_reads=sline[-1]
        sample_name=sline[0]
        #trimmed_reads=sline2[-1]
        reads_stats.append([sample_name,total_reads])
    return reads_stats

#this creates the template
def template_creation(project,run):
  with open(project+'_'+run+'.tex', 'w') as f:
    f.write(r"""\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Exeter sequencing report project}
\author{Exeter Sequencing Team}


\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\newpage
\tableofcontents
\newpage
"""
)

#This populates the template
def test_populate(project,run):
   with open('folder.txt',encoding = "ascii") as folder_l,open(project+'_'+run+'.tex', 'a') as f:
        Lines = folder_l.readlines()
        for line in Lines:
            print(line)
            if "01_raw_reads" in line:
               f.write(r"""\section{01\_raw\_reads}

Raw reads are primarily generated by demultiplexing the run. The Run is demultiplexed with the following command.
\\
\begin{verbatim}
conda activate illumina_bcl
    time bcl2fastq \
        --output-dir demux.${dx} \
        --sample-sheet ss.${dx}.csv \
        --no-lane-splitting \
       --barcode-mismatches 1;\\
\end{verbatim}

For longer paired end barcode 1 mismatch is used. On the other hand for shorter single end libraries the option \verb+ --barcode-mismatches 0;+ is used.


\newpage""")
            if "09_QC_reports" in line:
                f.write(r"""\section{09\_QC\_reports}

The 09\_QC\_reports has a few reports generated throughout the quality control checks performed.Fastqc is performed on the trimmed and raw reads. Fastq screen only on the trimmed reads and a summary of the trimmed is below.
\\
\\
Megablast is run on the first read 10,000 reads. An RRNA or a nucletide database is run depending on the nature of the experience for example Amplicon and metagenomic projects will be blasted against an RRNA based database. The results are visualised using Krona.
\\
\\
Sample,Number of reads,Number of reads after trimming


\newpage""")
            if "11_fastp_trimmed" in line:
                f.write(r"""\section{11\_fastp\_trimmed}
The software fastp was used to generate the trimmed reads. The options for the trimming can be be found in the the project\_options.sh file. Bases lower than Q\$\{qscore\} were trimmed from the 3' end.Reads shorter than \$\{length\_required\} were discarded.The \verb+--trim_front=1+ option is only used in RNA libraries with a T base starting all sequences. This step only removes adapter-sequences. Primer/UMI/internal barcode trimming will still be on the sequence at this stage.

\begin{verbatim}
fastp \
        --detect_adapter_for_pe \
        --cut_tail \
        --cut_tail_mean_quality=${qscore} \
        --length_required=${length_required} \
        --trim_front1=${trim_front1:-0} \
        --thread=8 \
        --in1=${input_folder}/${sample}_R1_${input_suffix} \
        --in2=${input_folder}/${sample}_R2_${input_suffix} \
        --out1=${output_folder}/${sample}_R1_${output_suffix} \
        --out2=${output_folder}/${sample}_R2_${output_suffix} \
        --html=${reports_folder}/${sample}_fastp.html \
        --json=${reports_folder}/${sample}_fastp.json
\end{verbatim}

\newpage""")
            if "02_dephase" in line:
                f.write(r"""\section{02\_dephased}

In certain occasion during the library prep phasing might be added to increase the sequence complexity of the sequence and increase the accuracy of the reads.For 16S V4 regions these are the phasing options for the forward sequence:T, CA, ACACA, none and these are phasing options for the reverse sequence:T, AC, CCT, none. For 18S V9 these are the phasing options for the forward read:G,CG,CT and these are for the reverse:AT,T,A,TC.

In house scripts are utilised to remove these extra bases before adapter trimming.

\newpage""")
            if "12_cutadapt_trimmed" in line:
                f.write(r"""\section{12\_cutadapt\_trimmed}
The software cutadapt was used to generate the trimmed reads. The options for the trimming can be be found in the the project\_options.sh file. Bases lower than Q\$\{qscore\} were trimmed from the 3' end.Reads shorter than \$\{length\_required\} were discarded.The Q\$\{qscore\} and \$\{length\_required\} were selected based on the initial inspection. This step only removes adapter-sequences. Primer/UMI/internal barcode trimming will still be on the sequence at this stage.

\begin{verbatim}
cutadapt \
        -a TruSeq1=AGATCGGAAGAGCACACGTCTGAACTCCAGTCA \
        -a Nextera=CTGTCTCTTATACACATCT \
        -a SmallRNA=TGGAATTCTCGGGTGCCAAGG \
        -a NEBNextsmallRNA=GATCGTCGGACTGTAGAACTCTGAA \
        -A TruSeq2=AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT \
        -A Nextera=CTGTCTCTTATACACATCT \
        -A SmallRNA=TGGAATTCTCGGGTGCCAAGG \
        -A NEBNextsmallRNA=GATCGTCGGACTGTAGAACTCTGAA \
        --cores 8 \
        --quality-cutoff=${qscore} \
        --minimum-length=${length_required} \
        --error-rate=0.11 \
        --overlap=5 \
        --pair-filter=any \
        --output=${output_folder}/${sample}_R1_${output_suffix} \
        --paired-output=${output_folder}/${sample}_R2_${output_suffix} \
        ${input_folder}/${sample}_R1_${input_suffix} \
        ${input_folder}/${sample}_R2_${input_suffix}
\end{verbatim}


\newpage""")

        
#This ends the template
def end_document(project,run):
  with open(project+'_'+run+'.tex', 'a') as f:
    f.write(r"""\newpage
\end{document}""")

print(data_extraction_multiqc(str(project),str(run)))
template_creation(str(project),str(run))
test_populate(str(project),str(run))
end_document(str(project),str(run))
